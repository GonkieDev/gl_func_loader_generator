// Author: Goncalo Pestana (aka: gsp, GonkDev)
// License: MIT
// Credits: Dion Systems for making metadesk

// NOTE: this repo does not have metadesk files, you must download those separely from:
// https://github.com/Dion-Systems/metadesk/tree/master/source
// You only need "md.h", "md.c" and "md_stb_sprintf.h" (files in source folder)

// This is a simple OpenGL function loader that generates function typedefs, pointers, 
// and sets those pointers based on an input file
// Written in one late afternoon in order to learn metadesk so code is kind of thrash, but does the job
// Handles some errors but not all, but pasting from khronos website and adding the @gl before should work

// Example usage:
// gl_func_loader_codegen.exe test.mdesk
// (input files don't have to be .mdesk, just need to be text)

// Example syntax (check test.mdesk for more)
// e.g. @gl void glDeleteFrameBuffers(n, const GLuint *framebuffers);

// The @gl must be there, otherwise line is ignore
// You can use @typedef_only for a typedef only function, or @debug for debug only functions (see below)
// There's also various options you can tweak without understanding the code

// Cool things to add:
// - Source code scanner that detects which functions you're using
// - Better error catching and logging

/////////////////////////////////////////////////////////////////////////////////
//~ Settings

// NOTE(gsp): Input file text must have '@' before these
#define GFLC_GL_TAG "gl" 
// Will be included in debug only
#define GFLC_DEBUG_TAG "debug"
#define GFLC_DEBUG_GUARD "BUILD_DEBUG"
// Will not output function ptr, only typedef
#define GFLC_TYPEDEF_ONLY_TAG "typedef_only"

//- Output settings
#define GFLC_OUTPUT_FILE_NAME "gl_func_loader_generated" // NOTE(gsp): don't include '.h' here
#define GFLC_USE_GUARDS 1
//#define GFLC_GUARD EXAMPLE_INCLUDE_GUARD_H // NOTE(gsp): use this if you want to overwrite include guard
#define GFLC_GL_FUNC_NAME "gl_func" // NOTE(gsp): gets put before every function pointer on output
#define GFLC_GL_FUNC "static"

#define GFLC_GET_GL_FUNC_PTR_FUNCTION_NAME "R_GL_GetGLFuncAddress"
#define GFLC_LOADER_FUNCTION "inline_function void\nR_GL_InitFunctionPointers"

#define GFLC_VISUAL_DIVISION "\n\n\n\n/////////////////////////////////////////////////////////\n"

//- Log settings
#define GFLC_DISABLE_WARNINGS   0
#define GFLC_DUPLICATE_WARNING  1
#define GLLC_NO_TAG_WARNING     1
#define GFLC_LOG_FUNCTION_NAMES 1

/////////////////////////////////////////////////////////////////////////////////
//~ [h] includes
#include "md.h"

#define PrintGenNoteCComment(f) fprintf((f), "// generated by %s:%d\n", __FILENAME__, __LINE__)
#undef MD_PrintGenNoteCComment
#define MD_PrintGenNoteCComment PrintGenNoteCComment

#define UnreferencedParameter(param) ((void)param)

//////////////////////////////////////////////////////////////////////
//~ types
typedef struct GFLC_GL_FuncInfo GFLC_GL_FuncInfo;
struct GFLC_GL_FuncInfo
{
    GFLC_GL_FuncInfo *next;
    MD_Node *node;
    MD_Node *returnType;  // e.g. void, int, ...
    MD_Node *funcName;    // e.g. glGenVertexArrays
    MD_Node *first_param;
    MD_Node *last_param;
    
    // NOTE(gsp): this is here because sometimes you get certain functions without names such as:
    // void (APIENTRY *DEBUGPROC)(GLenum source,  GLenum type, GLuint id, GLenum severity, 
    //                            GLsizei length, const GLchar* message, const void* userParam);
    MD_b32 typedefOnly;
    MD_String8 funcNameStr;
    
    MD_String8 paramsStr;
    MD_String8 functionType; // e.g. gl_gen_vertex_arrays
    MD_b32 debugOnly;
};

/////////////////////////////////////////////////////////////////////////////////
//~ globals
static MD_Arena *arena = 0;

FILE *error_file = 0;

GFLC_GL_FuncInfo *first_gl_func = 0;
GFLC_GL_FuncInfo *last_gl_func = 0;
MD_Map gl_func_map = {0};

#include <string.h>
#if defined(_WIN32)
# define __FILENAME__ (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)
#else
# define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#endif

//////////////////////////////////////////////////////////////////////
//~ Forward decls

//- Setup funcs
MD_Node *gflc_parse_files(int argc, char **argv);

//- Output functions
MD_String8 gflc_get_function_typedef(MD_Arena *arena, GFLC_GL_FuncInfo *func_info);
void gflc_output_all_functions_typedef(FILE *f);
void gflc_output_all_function_pointers(FILE *f);
void gflc_output_loader_function(FILE *f);

//- Gen funcs
void gflc_parse_function_inputs(MD_Node *list);
MD_Node* gflc_get_function_node_by_name(MD_String8 name);

//- Warnings
void gflc_duplicate_function_warning(MD_Node *new_node, MD_Node *existing_node);
MD_b32 gflc_check_and_do_duplicate_function_warning(MD_Node *new_node);

MD_b32 gflc_func_info_is_valid(GFLC_GL_FuncInfo *func_info);

void gflc_no_gl_tag_warning(MD_Node *node);

//////////////////////////////////////////////////////////////////////
//~ main
int
main(int argc, char **argv)
{
    //- Initial Setup
    arena = MD_ArenaAlloc();
    error_file = stderr;
    gl_func_map = MD_MapMake(arena);
    
    //- Analysis
    MD_Node *node_list = gflc_parse_files(argc, argv);
    gflc_parse_function_inputs(node_list);
    
    //- Generated output file
    {
        FILE *h = fopen(GFLC_OUTPUT_FILE_NAME ".h", "wb");
        
        // Include guards
#if GFLC_USE_GUARDS
# if !defined(GFLC_GUARD)
#  define GFLC_GUARD GFLC_OUTPUT_FILE_NAME "_INCLUDE_H"
# endif
        fprintf(h, "#if !defined(" GFLC_GUARD ")\n");
        fprintf(h, "#define " GFLC_GUARD "\n\n");
#endif // #if GFLC_USE_GUARDS
        
        fprintf(h, GFLC_VISUAL_DIVISION);
        fprintf(h, "//~ Function typedefs\n");
        gflc_output_all_functions_typedef(h);
        
        fprintf(h, GFLC_VISUAL_DIVISION);
        fprintf(h, "//~ Function pointers\n");
        fprintf(h, "#define " GFLC_GL_FUNC_NAME " " GFLC_GL_FUNC "\n\n");
        gflc_output_all_function_pointers(h);
        
        fprintf(h, GFLC_VISUAL_DIVISION);
        fprintf(h, "//~ Loader Function\n");
        gflc_output_loader_function(h);
        
        fprintf(h, GFLC_VISUAL_DIVISION);
        fprintf(h, "//~ End of generated file\n");
        
#if GFLC_USE_GUARDS
        fprintf(h, "#endif // " GFLC_GUARD "\n");
#endif
        
        fclose(h);
    }
    
    
#if GFLC_LOG_FUNCTION_NAMES
    MD_u32 functionsCount = 0;
    printf("GL functions used:\n");
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->typedefOnly)
            continue;
        
        functionsCount++;
        printf("\t%.*s %.*s", MD_S8VArg(func_info->returnType->string), MD_S8VArg(func_info->funcNameStr));
        printf("%.*s", MD_S8VArg(func_info->paramsStr));
        printf(";\n");
    }
    printf("Total function count: %d\n", functionsCount);
#endif
}

//////////////////////////////////////////////////////////////////////
//~ Setup funcs
MD_Node *
gflc_parse_files(int argc, char **argv)
{
    // parse all files passed to the command line
    MD_Node *list = MD_MakeList(arena);
    for (int i = 1; i < argc; i += 1)
    {
        // parse the file
        MD_String8 file_name = MD_S8CString(argv[i]);
        MD_ParseResult parse_result = MD_ParseWholeFile(arena, file_name);
        
        // print metadesk errors
        for (MD_Message *message = parse_result.errors.first;
             message != 0;
             message = message->next)
        {
            MD_CodeLoc code_loc = MD_CodeLocFromNode(message->node);
            MD_PrintMessage(error_file, code_loc, message->kind, message->string);
        }
        
        // save to parse results list
        MD_PushNewReference(arena, list, parse_result.node);
    }
    return list;
}

//////////////////////////////////////////////////////////////////////
//~ @Output_functions
MD_String8
gflc_get_function_typedef(MD_Arena *arena, GFLC_GL_FuncInfo *func_info)
{
    MD_String8 typeStr = func_info->typedefOnly ? func_info->funcNameStr : func_info->functionType;
    MD_String8 result = MD_S8Fmt(arena, "typedef %.*s %.*s%.*s;", 
                                 MD_S8VArg(func_info->returnType->string),
                                 MD_S8VArg(typeStr),
                                 MD_S8VArg(func_info->paramsStr));
    return result;
}

void
gflc_output_all_functions_typedef(FILE *f)
{
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->debugOnly) // non-debug only
            continue;
        MD_ArenaTemp scratch = MD_ArenaBeginTemp(arena);
        MD_String8 typedefStr = gflc_get_function_typedef(scratch.arena, func_info);
        fprintf(f, "%.*s\n", MD_S8VArg(typedefStr));
        MD_ArenaEndTemp(scratch);
    }
    
    fprintf(f, "#if defined(" GFLC_DEBUG_GUARD ")\n");
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (!func_info->debugOnly) // debug only
            continue;
        MD_ArenaTemp scratch = MD_ArenaBeginTemp(arena);
        MD_String8 typedefStr = gflc_get_function_typedef(scratch.arena, func_info);
        fprintf(f, "%.*s\n", MD_S8VArg(typedefStr));
        MD_ArenaEndTemp(scratch);
    }
    fprintf(f, "#endif // " GFLC_DEBUG_GUARD "\n");
}

void
gflc_output_all_function_pointers(FILE *f)
{
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->typedefOnly || func_info->debugOnly)
            continue;
        
        fprintf(f, GFLC_GL_FUNC_NAME " %.*s *%.*s;\n", MD_S8VArg(func_info->functionType), MD_S8VArg(func_info->funcNameStr));
    }
    
    fprintf(f, "#if defined(" GFLC_DEBUG_GUARD ")\n");
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->typedefOnly || !func_info->debugOnly)
            continue;
        fprintf(f, GFLC_GL_FUNC_NAME " %.*s *%.*s;\n", MD_S8VArg(func_info->functionType), MD_S8VArg(func_info->funcNameStr));
    }
    fprintf(f, "#endif // " GFLC_DEBUG_GUARD "\n");
}

void
gflc_output_loader_function(FILE *f)
{
    fprintf(f, GFLC_LOADER_FUNCTION "(void)\n{\n");
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->typedefOnly || func_info->debugOnly)
            continue;
        
        fprintf(f, "\t%.*s = (%.*s *)" GFLC_GET_GL_FUNC_PTR_FUNCTION_NAME "(\"%.*s\");\n", 
                MD_S8VArg(func_info->funcNameStr),
                MD_S8VArg(func_info->functionType),
                MD_S8VArg(func_info->funcNameStr));
    }
    
    fprintf(f, "#if defined(" GFLC_DEBUG_GUARD ")\n");
    for (GFLC_GL_FuncInfo *func_info = first_gl_func;
         func_info != 0;
         func_info = func_info->next)
    {
        if (func_info->typedefOnly || !func_info->debugOnly)
            continue;
        
        fprintf(f, "\t%.*s = (%.*s *)" GFLC_GET_GL_FUNC_PTR_FUNCTION_NAME "(\"%.*s\");\n", 
                MD_S8VArg(func_info->funcNameStr),
                MD_S8VArg(func_info->functionType),
                MD_S8VArg(func_info->funcNameStr));
    }
    fprintf(f, "#endif // " GFLC_DEBUG_GUARD "\n");
    
    fprintf(f, "}\n");
}

//////////////////////////////////////////////////////////////////////
//~ @Gen_funcs
void
gflc_parse_function_inputs(MD_Node *list)
{
    for(MD_EachNode(ref, list->first_child))
    {
        MD_Node *root = MD_ResolveNodeFromReference(ref);
        for(MD_EachNode(node, root->first_child))
        {
            MD_Node *gl_func_tag =  MD_TagFromString(node, MD_S8Lit(GFLC_GL_TAG), 0);
            if (!MD_NodeIsNil(gl_func_tag))
            {
                GFLC_GL_FuncInfo func_info = MD_ZERO_STRUCT;
                func_info.node = node;
                func_info.returnType = node;
                func_info.funcName = (!MD_NodeIsNil(node->next) && !gflc_check_and_do_duplicate_function_warning(node->next)) ? node->next : MD_NilNode();
                func_info.first_param = (!MD_NodeIsNil(node->next->next->first_child)) ? node->next->next->first_child : MD_NilNode();
                func_info.last_param = func_info.first_param;
                
                // Get func name str
                if (!MD_NodeIsNil(func_info.funcName->first_child))
                {
                    MD_Node *first_child = func_info.funcName->first_child;
                    MD_Node *last_child = first_child;
                    for (MD_EachNode(child, first_child))
                    {
                        last_child = child;
                    }
                    MD_u32 strLen = last_child->string.size + last_child->offset - first_child->offset;
                    func_info.funcNameStr = MD_S8Fmt(arena, "%(%.*s)", strLen, first_child->string.str);
                }
                else
                {
                    func_info.funcNameStr = func_info.funcName->string;
                }
                
                // Get params string
                {
                    for (MD_EachNode(child, func_info.first_param))
                    {
                        func_info.last_param = child;
                    }
                    MD_u32 paramsStrLen = func_info.last_param->string.size + func_info.last_param->offset - func_info.first_param->offset;
                    func_info.paramsStr = MD_S8Fmt(arena, "%(%.*s)", paramsStrLen, func_info.first_param->string.str);
                }
                
                // Get stylized function type
                {
                    MD_IdentifierStyle identifierStyle = MD_IdentifierStyle_UpperCase;
                    MD_String8 separator = MD_ZERO_STRUCT;
                    func_info.functionType = MD_S8Stylize(arena, func_info.funcNameStr, identifierStyle, separator);
                }
                
                // Check if typedef only
                {
                    MD_Node *typedefOnlyTag = MD_TagFromString(node, MD_S8Lit(GFLC_TYPEDEF_ONLY_TAG ), 0);
                    MD_b32 typedefOnly = !(MD_NodeIsNil(typedefOnlyTag));
                    func_info.typedefOnly = typedefOnly;
                }
                
                // Check if debug only
                {
                    MD_Node *debugTag = MD_TagFromString(node, MD_S8Lit(GFLC_DEBUG_TAG), 0);
                    MD_b32 debugOnly = !(MD_NodeIsNil(debugTag));
                    func_info.debugOnly = debugOnly;
                }
                
                // Commit to linked list & map
                if (gflc_func_info_is_valid(&func_info))
                {
                    GFLC_GL_FuncInfo *allocated_func_info = (GFLC_GL_FuncInfo *)MD_ArenaPush(arena, sizeof(GFLC_GL_FuncInfo));
                    *allocated_func_info = func_info;
                    MD_QueuePush(first_gl_func, last_gl_func, allocated_func_info);
                    MD_MapInsert(arena, &gl_func_map, MD_MapKeyStr(func_info.funcNameStr), allocated_func_info);
                }
            }
        }
    }
}

MD_Node*
gflc_get_function_node_by_name(MD_String8 name)
{
    MD_Node *result = MD_NilNode();
    MD_MapSlot *func_slot  = MD_MapLookup(&gl_func_map, MD_MapKeyStr(name));
    if (func_slot != 0)
    {
        GFLC_GL_FuncInfo *func_info = (GFLC_GL_FuncInfo*)func_slot->val; 
        result = func_info->node;
    }
    return result;
}

//////////////////////////////////////////////////////////////////////
//~ Warnings
void
gflc_duplicate_function_warning(MD_Node *new_node, MD_Node *existing_node)
{
#if !GFLC_DISABLE_WARNINGS && GFLC_DUPLICATE_WARNING
    MD_CodeLoc loc = MD_CodeLocFromNode(new_node);
    MD_PrintMessageFmt(error_file, loc, MD_MessageKind_Warning,
                       "Function name '%.*s' is already used",
                       MD_S8VArg(new_node->string));
    MD_CodeLoc existing_loc = MD_CodeLocFromNode(existing_node); 
    MD_PrintMessageFmt(error_file, existing_loc, MD_MessageKind_Note,
                       "See '%.*s' is already used",
                       MD_S8VArg(existing_node->string));
#else
    UnreferencedParameter(new_node);
    UnreferencedParameter(existing_node);
#endif
}

MD_b32
gflc_check_and_do_duplicate_function_warning(MD_Node *new_node)
{
    MD_b32 result = 0;
    MD_Node *existing = gflc_get_function_node_by_name(new_node->string);
    if (!MD_NodeIsNil(existing))
    {
        gflc_duplicate_function_warning(new_node, existing);
        result = 1;
    }
    return result;
}

MD_b32
gflc_func_info_is_valid(GFLC_GL_FuncInfo *func_info)
{
    MD_b32 result = 1;
    
    if (MD_NodeIsNil(func_info->returnType) || 
        MD_NodeIsNil(func_info->funcName) || 
        func_info->funcNameStr.size == 0 || (func_info->typedefOnly && func_info->funcNameStr.size == 2))
    {
        result = 0;
        
        MD_CodeLoc loc = MD_CodeLocFromNode(func_info->node);
        MD_PrintMessageFmt(error_file, loc, MD_MessageKind_Error,
                           "Parse error.");
    }
    
    return result;
}

//////////////////////////////////////////////////////////////////////
//~ [c] includes
#include "md.c"

//////////////////////////////////////////////////////////////////////
//~ END OF FILE